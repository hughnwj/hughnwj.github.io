<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>day1 快排，归并排序，二分查找</title>
      <link href="/2024/11/11/day1%20%E5%BF%AB%E6%8E%92%EF%BC%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/11/11/day1%20%E5%BF%AB%E6%8E%92%EF%BC%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-基础算法"><a href="#第一章-基础算法" class="headerlink" title="第一章 基础算法"></a>第一章 基础算法</h1><p><code>请你为下列代码添加详细的中文注释，并在代码结尾的注释中给出一个测试案例以及对应的标准答案以及代码输出的答案</code></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; // 引入标准输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int size_max = 1e6; // 定义一个常量size_max，值为1000000，用于数组大小</span><br><span class="line">const int N = size_max + 10; // 定义一个常量N，比size_max大10，用于确保数组不会越界</span><br><span class="line"></span><br><span class="line">int n; // 定义全局变量n，用于存储待排序元素的数量</span><br><span class="line">int q[N]; // 定义全局数组q，用于存储待排序的元素</span><br><span class="line"></span><br><span class="line">// 快速排序函数</span><br><span class="line">// 参数q[]为待排序的数组，l为当前处理的子数组左边界，r为当前处理的子数组右边界</span><br><span class="line">void quick_sort(int q[], int l, int r) &#123;</span><br><span class="line">    // 如果当前子数组的左边界大于或等于右边界，说明子数组长度为0或1，无需排序，直接返回</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    </span><br><span class="line">    // 选择子数组左边界元素作为基准值</span><br><span class="line">    int x = q[l];</span><br><span class="line">    // 初始化两个指针，i指向左边界左侧，j指向右边界右侧</span><br><span class="line">    int i = l - 1, j = r + 1;</span><br><span class="line">    </span><br><span class="line">    // 当两个指针没有相遇时，执行以下循环</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 移动指针i，直到找到一个不小于基准值的元素</span><br><span class="line">        while (q[++i] &lt; x);</span><br><span class="line">        // 移动指针j，直到找到一个不大于基准值的元素</span><br><span class="line">        while (q[--j] &gt; x);</span><br><span class="line">        // 如果i和j没有相遇，交换它们指向的元素</span><br><span class="line">        if (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递归地对基准值左侧的子数组进行快速排序</span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    // 递归地对基准值右侧的子数组进行快速排序</span><br><span class="line">    quick_sort(q, j + 1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 从标准输入读取待排序元素的数量</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    // 循环读取每个待排序的元素，并存储到数组q中</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 调用快速排序函数，对数组q进行排序</span><br><span class="line">    quick_sort(q, 0, n - 1);</span><br><span class="line">    </span><br><span class="line">    // 循环输出排序后的数组元素</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, q[i]);</span><br><span class="line">        // 输出元素后加一个空格分隔</span><br><span class="line">        if (i &lt; n - 1) printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出换行符，表示输出结束</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0; // 主函数返回0，表示程序正常结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">3 1 4 1 5</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">1 1 3 4 5</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">1 1 3 4 5</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; // 引入标准输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int size_max = 1e6; // 定义一个常量size_max，值为1000000，用于数组大小</span><br><span class="line">const int N = size_max + 10; // 定义一个常量N，比size_max大10，用于确保数组不会越界</span><br><span class="line"></span><br><span class="line">int n; // 定义全局变量n，用于存储待排序元素的数量</span><br><span class="line">int q[N], tem[N]; // 定义两个全局数组q和tem，q用于存储待排序的元素，tem用于归并排序中的临时数组</span><br><span class="line"></span><br><span class="line">// 归并排序函数，参数q是待排序的数组，l是左边界，r是右边界</span><br><span class="line">void merge_sort(int q[], int l, int r) &#123;</span><br><span class="line">    // 如果左边界大于等于右边界，说明已经不能再分，直接返回</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    </span><br><span class="line">    // 计算中间位置</span><br><span class="line">    int mid = (l + r) &gt;&gt; 1; // 等同于mid = (l + r) / 2，但使用位运算更高效</span><br><span class="line">    </span><br><span class="line">    // 递归地对左半部分进行归并排序</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    // 递归地对右半部分进行归并排序</span><br><span class="line">    merge_sort(q, mid + 1, r);</span><br><span class="line">    </span><br><span class="line">    // 归并两个有序数组</span><br><span class="line">    int i = l, j = mid + 1, k = 0; // 初始化三个指针，i指向左半部分的起始位置，j指向右半部分的起始位置，k指向临时数组的起始位置</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; // 当两个指针都没有到达各自数组的末尾时</span><br><span class="line">        if (q[i] &lt;= q[j]) &#123; // 如果左半部分的当前元素小于等于右半部分的当前元素</span><br><span class="line">            tem[k++] = q[i++]; // 将左半部分的当前元素放入临时数组，并将i和k指针后移</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tem[k++] = q[j++]; // 将右半部分的当前元素放入临时数组，并将j和k指针后移</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将剩余的左半部分元素放入临时数组</span><br><span class="line">    while (i &lt;= mid) tem[k++] = q[i++];</span><br><span class="line">    // 将剩余的右半部分元素放入临时数组</span><br><span class="line">    while (j &lt;= r) tem[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    // 将临时数组中的元素拷贝回原数组</span><br><span class="line">    for (int i = 0, j = l; i &lt; k; i++, j++) &#123;</span><br><span class="line">        q[j] = tem[i]; // 从临时数组拷贝元素到原数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 从标准输入读取元素数量</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    // 从标准输入读取每个元素</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 调用归并排序函数对数组进行排序</span><br><span class="line">    merge_sort(q, 0, n - 1);</span><br><span class="line">    </span><br><span class="line">    // 输出排序后的数组</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, q[i]); // 输出每个元素，后面跟一个空格</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出换行符表示输出结束</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0; // 主函数返回0，表示程序正常结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">6</span><br><span class="line">9 5 2 7 1 8</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">1 2 5 7 8 9 </span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">1 2 5 7 8 9</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; // 引入标准输入输出流库</span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int size_max = 100; // 定义常量size_max，表示数组的最大元素数量</span><br><span class="line">const int N = size_max + 10; // 定义常量N，比size_max大10，用于确保数组不越界</span><br><span class="line"></span><br><span class="line">int n; // 定义全局变量n，用于存储数组a的元素数量</span><br><span class="line">int a[N]; // 定义全局数组a，用于存储第一个整数数组</span><br><span class="line">int m; // 定义全局变量m，用于存储数组b的元素数量</span><br><span class="line">int b[N]; // 定义全局数组b，用于存储第二个整数数组（查询数组）</span><br><span class="line"></span><br><span class="line">// 快速排序函数</span><br><span class="line">// 参数q[]为待排序的数组，l为当前处理的子数组左边界，r为当前处理的子数组右边界</span><br><span class="line">void quick_sort(int q[], int l, int r) &#123;</span><br><span class="line">    // 如果左边界大于或等于右边界，说明子数组长度为0或1，直接返回</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    int x = q[l], i = l - 1, j = r + 1; // x为基准值，i初始化为l-1，j初始化为r+1</span><br><span class="line">    // 循环进行分区操作</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 移动i，直到找到大于等于基准值的元素</span><br><span class="line">        while (q[++i] &lt; x);</span><br><span class="line">        // 移动j，直到找到小于等于基准值的元素</span><br><span class="line">        while (q[--j] &gt; x);</span><br><span class="line">        // 如果i小于j，交换两个元素</span><br><span class="line">        if (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归对基准值左侧的子数组排序</span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    // 递归对基准值右侧的子数组排序</span><br><span class="line">    quick_sort(q, j + 1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分查找函数，检查数组a中是否存在目标值x</span><br><span class="line">// 参数x为查找目标，a[]为数组，l为当前子数组左边界，r为右边界</span><br><span class="line">bool find_x(int x, int a[], int l, int r) &#123;</span><br><span class="line">    // 如果左边界大于右边界，说明区间无效，返回false</span><br><span class="line">    if (l &gt; r) return false;</span><br><span class="line">    int mid = (l + r) &gt;&gt; 1; // 计算中间位置，等同于(l + r) / 2</span><br><span class="line">    // 如果x大于中间元素，缩小搜索区间至右半部分</span><br><span class="line">    if (x &gt; a[mid]) &#123;</span><br><span class="line">        l = mid + 1;</span><br><span class="line">        return find_x(x, a, l, r); // 递归查找右半部分</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果x小于中间元素，缩小搜索区间至左半部分</span><br><span class="line">    else if (x &lt; a[mid]) &#123;</span><br><span class="line">        r = mid - 1;</span><br><span class="line">        return find_x(x, a, l, r); // 递归查找左半部分</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到目标元素，返回true</span><br><span class="line">    else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 读取数组a的元素数量</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    // 读取数组a的元素</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 读取数组b的元素数量</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">    // 读取数组b的元素</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 对数组a进行快速排序，便于后续二分查找</span><br><span class="line">    quick_sort(a, 0, n - 1);</span><br><span class="line">    </span><br><span class="line">    // 对于数组b中的每个元素，判断它是否存在于已排序的数组a中</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        // 如果找到元素，输出&quot;YES&quot;</span><br><span class="line">        if (find_x(b[i], a, 0, n - 1)) &#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则输出&quot;NO&quot;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">3 1 4 1 5</span><br><span class="line">3</span><br><span class="line">2 4 5</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客建立教程</title>
      <link href="/2024/10/17/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E6%95%99%E7%A8%8B/"/>
      <url>/2024/10/17/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>hexo c   #清除缓存文件 db.json 和已生成的静态文件 public<br>hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)<br>hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
