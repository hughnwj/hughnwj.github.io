<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>觅长生 金虹快剑 练气</title>
      <link href="/2024/12/17/%E8%A7%85%E9%95%BF%E7%94%9F-%E9%87%91%E8%99%B9-%E7%BB%83%E6%B0%94/"/>
      <url>/2024/12/17/%E8%A7%85%E9%95%BF%E7%94%9F-%E9%87%91%E8%99%B9-%E7%BB%83%E6%B0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="觅长生-金虹快剑-练气"><a href="#觅长生-金虹快剑-练气" class="headerlink" title="觅长生 金虹快剑 练气"></a>觅长生 金虹快剑 练气</h1><h2 id="天赋"><a href="#天赋" class="headerlink" title="天赋"></a>天赋</h2><table><thead><tr><th>类别</th><th>特点</th></tr></thead><tbody><tr><td>难度</td><td>普通</td></tr><tr><td>设定</td><td>异世傲天</td></tr><tr><td>出生</td><td>书香门第</td></tr><tr><td>资质</td><td>天灵根 先天异脉</td></tr><tr><td>灵根</td><td>金</td></tr><tr><td>体质</td><td>先天异脉，先天道体，龙族血脉，异族血脉，转世仙人</td></tr><tr><td>儿时经历</td><td>大病一场，星辰泪</td></tr><tr><td>青年经历</td><td>惨遭退婚，初窥门径</td></tr></tbody></table><h2 id="练气"><a href="#练气" class="headerlink" title="练气"></a>练气</h2><h3 id="第1年"><a href="#第1年" class="headerlink" title="第1年"></a>第1年</h3><ul><li>1，2月：东石谷（拍卖生骨丹）</li><li>3月：逸风城（卖星辰泪，买<strong>金光</strong>，见一仙道人），云汐城（卖草药，买十<strong>补天芝</strong>），广陵城（交易纠纷得甲，记住女修名字<strong>屈香露</strong>，卖材料），天星城（买<strong>龟息术</strong>），武陵城（买十化瘀丹加十疾行丹，存档，第一年英杰会，加入白帝楼，调查武陵城<strong>李天，魔神蛊，古神教</strong>，卖筑基丹），逸风城（卖玄天剑）</li><li>4月：sl四品丹炉，云汐城（采购部分药材），永安镇（永安学堂）</li><li>5月：金虹剑派（拜师<strong>明河</strong>，sl喜好）</li><li>炼丹赚钱（<strong>蚀月强魂丹</strong>），云汐城（采购剩余药材）</li></ul><h3 id="第二年"><a href="#第二年" class="headerlink" title="第二年"></a>第二年</h3><p>炼丹+一仙道人+龟息术</p><h3 id="第三年"><a href="#第三年" class="headerlink" title="第三年"></a>第三年</h3><p>一仙道人+武陵城（丹炉）+云汐城（采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>）+炼丹</p><h3 id="第四年"><a href="#第四年" class="headerlink" title="第四年"></a>第四年</h3><p>封山之迷（<strong>古神教，黑心老人</strong>）+sl云秋兰（请教地元炼体决+加微信）+正阳山（赤须遗体+灵药泡澡）</p><h3 id="第五年"><a href="#第五年" class="headerlink" title="第五年"></a>第五年</h3><p>地元炼体决+论道（金，剑，气）+吐纳功法第三层（升练气中期）+神秘飞剑+武陵城（倪家，丹炉）+云汐城（采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>）+论道（金，剑，气）</p><h3 id="第六年"><a href="#第六年" class="headerlink" title="第六年"></a>第六年</h3><p>炼丹+武陵城（第六年英杰会）+广陵城（百里奇，买五<strong>火铜精</strong>）+星宫有铃+两派之争（沂山）+天机阁（<strong>重元换血草</strong>）</p><h3 id="第七年"><a href="#第七年" class="headerlink" title="第七年"></a>第七年</h3><p>sl东石谷拍卖会（<strong>长春通玄录</strong>）+找温杰（请教木系功法和竹山剑法，加微信）+找屈香露（加微信）+武陵城（巫山魔影，丹炉）+云汐城（采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>）+炼丹</p><h3 id="第八年"><a href="#第八年" class="headerlink" title="第八年"></a>第八年</h3><p>炼丹+地元炼体决第三层</p><h3 id="第九年"><a href="#第九年" class="headerlink" title="第九年"></a>第九年</h3><p>学木系功法+武陵城（丹炉）+云汐城（采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）+炼丹</p><h3 id="第十年"><a href="#第十年" class="headerlink" title="第十年"></a>第十年</h3><p>学木系功法和竹山剑法+论道（金，剑，气）</p><h3 id="第十一年"><a href="#第十一年" class="headerlink" title="第十一年"></a>第十一年</h3><p>武陵城（第十一年英杰会，丹炉）+云汐城（公孙季之约，采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）+重元换血草情报+天机阁（<strong>重元换血草</strong>）+炼丹</p><h3 id="第十二年"><a href="#第十二年" class="headerlink" title="第十二年"></a>第十二年</h3><p>论道（金，剑，气）+武陵城(丹炉，<strong>锻体丹</strong>）+逸风城（洞府，假人，找屈香露，买毒针）+学星河剑法+水木剑打假人+200层毒假人</p><h3 id="第十三年"><a href="#第十三年" class="headerlink" title="第十三年"></a>第十三年</h3><p>悟木系道+破庙相争</p><h3 id="第十四年"><a href="#第十四年" class="headerlink" title="第十四年"></a>第十四年</h3><p>逸风城（卖六魂幡，御灵盾）+武陵城(丹炉，<strong>锻体丹</strong>）+云汐城（采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）+天星城（买<strong>浑天术</strong>）+炼丹</p><h3 id="第十五年"><a href="#第十五年" class="headerlink" title="第十五年"></a>第十五年</h3><p>收集体系功法和木系功法+学习</p><h3 id="第十六年"><a href="#第十六年" class="headerlink" title="第十六年"></a>第十六年</h3><p>武陵城（丹炉，第十六年英杰会）+云汐城（采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>）+炼丹+倪旭欣隐龙窟探险</p><h3 id="第十七年"><a href="#第十七年" class="headerlink" title="第十七年"></a>第十七年</h3><p>重元换血草+天机阁调查+修炼体系神通和木系神通+论道（金，剑，体）+悟体道</p><h3 id="第十八年"><a href="#第十八年" class="headerlink" title="第十八年"></a>第十八年</h3><p>武陵城(丹炉）+云汐城采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）+炼丹</p><h3 id="第十九年"><a href="#第十九年" class="headerlink" title="第十九年"></a>第十九年</h3><p>修炼木系神通+论道（金，剑，体）+论道（木）+悟木道</p><h3 id="第二十年"><a href="#第二十年" class="headerlink" title="第二十年"></a>第二十年</h3><p>论道（木）+武陵城(丹炉）+云汐城采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）+炼丹</p><h3 id="第二十一年"><a href="#第二十一年" class="headerlink" title="第二十一年"></a>第二十一年</h3><p>悟木道+武陵城(丹炉，第二十一年英杰会）+学长春通玄录+方壶山</p><h3 id="第二十二年"><a href="#第二十二年" class="headerlink" title="第二十二年"></a>第二十二年</h3><p>武陵城(丹炉）+云汐城采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）+炼丹+论道（金，剑，体）</p><h3 id="第二十三年"><a href="#第二十三年" class="headerlink" title="第二十三年"></a>第二十三年</h3><p>重元换血草+悟体道</p><h3 id="第二十四年"><a href="#第二十四年" class="headerlink" title="第二十四年"></a>第二十四年</h3><p>武陵城(丹炉）+云汐城采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）+炼丹</p><h3 id="第二十五年"><a href="#第二十五年" class="headerlink" title="第二十五年"></a>第二十五年</h3><p>天机阁调查+再见星铃+悟体道+论道（金，剑，体）</p><h3 id="第二十六年"><a href="#第二十六年" class="headerlink" title="第二十六年"></a>第二十六年</h3><p>武陵城(丹炉）+云汐城采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）+炼丹+悟体道+论道（金，剑，体）</p><h3 id="第二十七年"><a href="#第二十七年" class="headerlink" title="第二十七年"></a>第二十七年</h3><p>修长春通玄录第二层</p><h3 id="第二十八年"><a href="#第二十八年" class="headerlink" title="第二十八年"></a>第二十八年</h3><p>武陵城(丹炉）+云汐城采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）</p><h3 id="第二十九年"><a href="#第二十九年" class="headerlink" title="第二十九年"></a>第二十九年</h3><p>炼丹+悟体道+论道（金，剑，体）</p><h3 id="第三十年"><a href="#第三十年" class="headerlink" title="第三十年"></a>第三十年</h3><p>找材料+练体丹+武陵城(丹炉）+云汐城采购<strong>凌风花，补天芝，天灵果，锦地罗，灯心草，幻心草</strong>，买<strong>黑天麻，冰精芝</strong>）</p><h3 id="第三十一年"><a href="#第三十一年" class="headerlink" title="第三十一年"></a>第三十一年</h3><p>吃丹药+炼丹</p><h3 id="第三十二年-第三十四年"><a href="#第三十二年-第三十四年" class="headerlink" title="第三十二年-第三十四年"></a>第三十二年-第三十四年</h3><p>浑天术两层+重元换血草+炼体丹+炼筑基丹药</p><h3 id="第三十五年"><a href="#第三十五年" class="headerlink" title="第三十五年"></a>第三十五年</h3><p>筑基！（2090血）</p>]]></content>
      
      
      <categories>
          
          <category> 金虹快剑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 觅长生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day6 拓扑序列</title>
      <link href="/2024/11/27/day6%20%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
      <url>/2024/11/27/day6%20%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-拓扑序列"><a href="#第七章-拓扑序列" class="headerlink" title="第七章 拓扑序列"></a>第七章 拓扑序列</h1><p><code>请你为下列代码添加详细的中文注释，并在代码结尾的注释中给出一个测试案例以及对应的标准答案以及代码输出的答案</code></p><h2 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;   // 引入queue库以使用队列</span><br><span class="line">#include &lt;vector&gt;  // 引入vector库以存储节点的出度信息</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 101; // 定义邻接矩阵的最大大小，最多可以存储N个节点之间的关系</span><br><span class="line"></span><br><span class="line">int edge[N][N];    // 定义邻接矩阵，用于存储图中节点之间的边关系</span><br><span class="line">int inDegree[N];   // 定义入度数组，用于记录每个节点的入度</span><br><span class="line">vector&lt;int&gt; result; // 存储拓扑排序结果</span><br><span class="line"></span><br><span class="line">// 拓扑排序函数（基于Kahn算法）</span><br><span class="line">void topologicalSort(int n) &#123;</span><br><span class="line">    queue&lt;int&gt; q; // 定义队列，用于存储入度为0的节点</span><br><span class="line"></span><br><span class="line">    // 初始化：将所有入度为0的节点加入队列</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (inDegree[i] == 0) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理队列中的节点</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int node = q.front(); // 获取队首节点</span><br><span class="line">        q.pop();              // 将队首节点出队</span><br><span class="line">        result.push_back(node); // 将节点加入拓扑排序结果</span><br><span class="line"></span><br><span class="line">        // 遍历当前节点的所有邻接节点</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (edge[node][i] == 1) &#123; // 如果存在从node到i的边</span><br><span class="line">                inDegree[i]--;        // 将目标节点的入度减1</span><br><span class="line">                if (inDegree[i] == 0) &#123;</span><br><span class="line">                    q.push(i); // 如果目标节点入度变为0，将其加入队列</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查是否存在环</span><br><span class="line">    if (result.size() &lt; n) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Graph contains a cycle. Topological sort not possible.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Topological Sort Order: &quot;;</span><br><span class="line">        for (int node : result) &#123;</span><br><span class="line">            cout &lt;&lt; node &lt;&lt; &quot; &quot;; // 输出拓扑排序结果</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));   // 将邻接矩阵初始化为0（表示无边）</span><br><span class="line">    memset(inDegree, 0, sizeof(inDegree)); // 将入度数组初始化为0</span><br><span class="line"></span><br><span class="line">    int n; // 定义变量n，用于存储图的节点数量</span><br><span class="line">    cin &gt;&gt; n; // 输入节点数量</span><br><span class="line"></span><br><span class="line">    int a, b; // 定义变量a和b，用于存储边的起点和终点</span><br><span class="line">    while (cin &gt;&gt; a &amp;&amp; cin &gt;&gt; b) &#123; // 持续读取边的起点和终点</span><br><span class="line">        edge[a][b] = 1;   // 在邻接矩阵中标记边（有向边：从a指向b）</span><br><span class="line">        inDegree[b]++;    // 增加目标节点b的入度</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Performing Topological Sort:&quot; &lt;&lt; endl;</span><br><span class="line">    topologicalSort(n); // 调用拓扑排序函数</span><br><span class="line">    return 0; // 程序执行完毕</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">6</span><br><span class="line">5 2</span><br><span class="line">5 0</span><br><span class="line">4 0</span><br><span class="line">4 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">-1 -1</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">- 图中有6个节点，节点编号为0到5。</span><br><span class="line">- 边的信息依次为：(5,2), (5,0), (4,0), (4,1), (2,3), (3,1)。</span><br><span class="line">- 输入边后，使用(-1, -1)作为结束标志。</span><br><span class="line"></span><br><span class="line">邻接矩阵：</span><br><span class="line">edge[5][2] = 1, edge[5][0] = 1</span><br><span class="line">edge[4][0] = 1, edge[4][1] = 1</span><br><span class="line">edge[2][3] = 1, edge[3][1] = 1</span><br><span class="line"></span><br><span class="line">入度数组：</span><br><span class="line">inDegree[0] = 2, inDegree[1] = 2</span><br><span class="line">inDegree[2] = 1, inDegree[3] = 1</span><br><span class="line">inDegree[4] = 0, inDegree[5] = 0</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">拓扑排序结果：4 5 2 3 1 0</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">Performing Topological Sort:</span><br><span class="line">Topological Sort Order: 4 5 2 3 1 0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="检测合法的拓扑序列"><a href="#检测合法的拓扑序列" class="headerlink" title="检测合法的拓扑序列"></a>检测合法的拓扑序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1001;</span><br><span class="line"></span><br><span class="line">int edge[N][N];</span><br><span class="line">int degree[N];</span><br><span class="line">int result[N];</span><br><span class="line"></span><br><span class="line">bool panduan(int n)&#123;</span><br><span class="line">    int newdegree[N];</span><br><span class="line">    memcpy(newdegree, degree, sizeof(degree));</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int node=result[i];</span><br><span class="line">        if(newdegree[node]!=0) return false;</span><br><span class="line">        </span><br><span class="line">        for(int j=1;j&lt;n+1;j++)&#123;</span><br><span class="line">            if(edge[node][j]==1)&#123;</span><br><span class="line">                newdegree[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(edge,0,sizeof(edge));</span><br><span class="line">    memset(degree,0,sizeof(degree));</span><br><span class="line">    memset(result,0,sizeof(result));</span><br><span class="line">    </span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        edge[a][b]=1;</span><br><span class="line">        degree[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;result[j];</span><br><span class="line">        &#125;</span><br><span class="line">        if(!panduan(n)) cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day5 BFS</title>
      <link href="/2024/11/26/day5%20BFS/"/>
      <url>/2024/11/26/day5%20BFS/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-BFS"><a href="#第六章-BFS" class="headerlink" title="第六章 BFS"></a>第六章 BFS</h1><p><code>请你为下列代码添加详细的中文注释，并在代码结尾的注释中给出一个测试案例以及对应的标准答案以及代码输出的答案</code></p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt; // 引入cstring库以使用memset函数</span><br><span class="line">#include &lt;queue&gt;   // 引入queue库以使用队列</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 101; // 定义邻接矩阵的最大大小，最多可以存储N个节点之间的关系</span><br><span class="line"></span><br><span class="line">int edge[N][N]; // 定义邻接矩阵，用于存储图中节点之间的边关系</span><br><span class="line">int visited[N]; // 定义访问标记数组，用于记录节点是否已经被访问</span><br><span class="line"></span><br><span class="line">// 广度优先搜索（BFS）函数</span><br><span class="line">void bfs(int start, int n) &#123;</span><br><span class="line">    queue&lt;int&gt; q;      // 定义队列，用于存储待访问的节点</span><br><span class="line">    q.push(start);     // 将起始节点加入队列</span><br><span class="line">    visited[start] = 1; // 标记起始节点为已访问</span><br><span class="line"></span><br><span class="line">    // 循环处理队列中的节点，直到队列为空</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int node = q.front(); // 获取队首节点</span><br><span class="line">        q.pop();              // 将队首节点出队</span><br><span class="line">        cout &lt;&lt; node &lt;&lt; &quot; &quot;;  // 输出当前访问的节点</span><br><span class="line"></span><br><span class="line">        // 遍历所有节点，检查当前节点的邻接节点</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            // 如果节点i与当前节点node相连，且节点i未被访问</span><br><span class="line">            if (edge[node][i] == 1 &amp;&amp; visited[i] == 0) &#123;</span><br><span class="line">                q.push(i);      // 将节点i加入队列</span><br><span class="line">                visited[i] = 1; // 标记节点i为已访问</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化邻接矩阵和访问标记数组</span><br><span class="line">    memset(edge, 0, sizeof(edge));    // 将邻接矩阵初始化为0（表示无边）</span><br><span class="line">    memset(visited, 0, sizeof(visited)); // 将访问标记数组初始化为0（表示未访问）</span><br><span class="line"></span><br><span class="line">    int n; // 定义变量n，用于存储图的节点数量</span><br><span class="line">    cin &gt;&gt; n; // 输入节点数量</span><br><span class="line"></span><br><span class="line">    int a, b; // 定义变量a和b，用于存储边的起点和终点</span><br><span class="line">    while (cin &gt;&gt; a &amp;&amp; cin &gt;&gt; b) &#123; // 持续读取边的起点和终点</span><br><span class="line">        edge[a][b] = 1; // 在邻接矩阵中标记边（有向边：从a指向b）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;BFS traversal starting from node 0:&quot; &lt;&lt; endl;</span><br><span class="line">    bfs(0, n); // 从节点0开始进行广度优先搜索</span><br><span class="line">    return 0; // 程序执行完毕</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">-1 -1</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">- 图中有5个节点，节点编号为0到4。</span><br><span class="line">- 边的信息依次为：(0,1), (0,2), (1,3), (1,4)。</span><br><span class="line">- 输入边后，使用(-1, -1)作为结束标志。</span><br><span class="line"></span><br><span class="line">邻接矩阵：</span><br><span class="line">edge[0][1] = 1, edge[0][2] = 1</span><br><span class="line">edge[1][3] = 1, edge[1][4] = 1</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">从节点0开始进行BFS遍历：</span><br><span class="line">BFS输出顺序：0 1 2 3 4</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">BFS traversal starting from node 0:</span><br><span class="line">0 1 2 3 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=41;</span><br><span class="line"></span><br><span class="line">int edge[N][N];</span><br><span class="line">int visit[N][N];</span><br><span class="line"></span><br><span class="line">void zoumigong(int start1,int start2,int n,int m)&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(start1);</span><br><span class="line">    q.push(start2);</span><br><span class="line">    q.push(1);</span><br><span class="line">    visit[start1][start2]=1;</span><br><span class="line">    </span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int temp1=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        // cout&lt;&lt;temp1&lt;&lt;&quot; &quot;;</span><br><span class="line">        int temp2=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        // cout&lt;&lt;temp2&lt;&lt;&quot; &quot;;</span><br><span class="line">        int temp3=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        // cout&lt;&lt;temp3&lt;&lt;endl;</span><br><span class="line">        if(temp1==n-1&amp;&amp;temp2==m-1)&#123;</span><br><span class="line">            cout&lt;&lt;temp3&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(temp1-1&gt;=0)&#123;</span><br><span class="line">            if(visit[temp1-1][temp2]==0&amp;&amp;edge[temp1-1][temp2]==1)&#123;</span><br><span class="line">                q.push(temp1-1);</span><br><span class="line">                q.push(temp2);</span><br><span class="line">                q.push(temp3+1);</span><br><span class="line">                visit[temp1-1][temp2]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(temp2-1&gt;=0)&#123;</span><br><span class="line">            if(visit[temp1][temp2-1]==0&amp;&amp;edge[temp1][temp2-1]==1)&#123;</span><br><span class="line">                q.push(temp1);</span><br><span class="line">                q.push(temp2-1);</span><br><span class="line">                q.push(temp3+1);</span><br><span class="line">                visit[temp1][temp2-1]=1;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(temp1+1&lt;n)&#123;</span><br><span class="line">            if(visit[temp1+1][temp2]==0&amp;&amp;edge[temp1+1][temp2]==1)&#123;</span><br><span class="line">                q.push(temp1+1);</span><br><span class="line">                q.push(temp2);</span><br><span class="line">                q.push(temp3+1);</span><br><span class="line">                visit[temp1+1][temp2]=1;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(temp2+1&lt;m)&#123;</span><br><span class="line">            if(visit[temp1][temp2+1]==0&amp;&amp;edge[temp1][temp2+1]==1)&#123;</span><br><span class="line">                q.push(temp1);</span><br><span class="line">                q.push(temp2+1);</span><br><span class="line">                q.push(temp3+1);</span><br><span class="line">                visit[temp1][temp2+1]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    memset(edge,0,sizeof(edge));</span><br><span class="line">    memset(visit,0,sizeof(visit));</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            char temp;</span><br><span class="line">            cin&gt;&gt;temp;</span><br><span class="line">            if(temp==&#x27;.&#x27;) edge[i][j]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    zoumigong(0,0,n,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day4 DFS</title>
      <link href="/2024/11/18/day4%20DFS/"/>
      <url>/2024/11/18/day4%20DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-DFS"><a href="#第五章-DFS" class="headerlink" title="第五章 DFS"></a>第五章 DFS</h1><p><code>请你为下列代码添加详细的中文注释，并在代码结尾的注释中给出一个测试案例以及对应的标准答案以及代码输出的答案</code></p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt; // 引入cstring库以使用memset函数</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 101; // 定义邻接矩阵的最大大小</span><br><span class="line"></span><br><span class="line">int edge[N][N]; // 邻接矩阵，用于存储图的边关系</span><br><span class="line">int visited[N]; // 访问标记数组，用于记录节点是否已访问</span><br><span class="line"></span><br><span class="line">// 深度优先搜索函数</span><br><span class="line">void dfs(int node, int n) &#123;</span><br><span class="line">    cout &lt;&lt; node &lt;&lt; &quot; &quot;; // 输出当前访问的节点</span><br><span class="line">    visited[node] = 1;   // 标记当前节点为已访问</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123; // 遍历所有节点，检查当前节点的邻接节点</span><br><span class="line">        // 如果存在边且目标节点未访问</span><br><span class="line">        if (edge[node][i] == 1 &amp;&amp; visited[i] == 0) &#123;</span><br><span class="line">            dfs(i, n); // 递归访问邻接节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 使用memset初始化邻接矩阵和访问标记数组</span><br><span class="line">    memset(edge, 0, sizeof(edge)); // 将邻接矩阵初始化为0（无边）</span><br><span class="line">    memset(visited, 0, sizeof(visited)); // 将访问标记数组初始化为0（未访问）</span><br><span class="line">    </span><br><span class="line">    int n; // 图的节点数</span><br><span class="line">    cin &gt;&gt; n; // 输入节点数</span><br><span class="line">    </span><br><span class="line">    int a, b; // 用于存储边的起点和终点</span><br><span class="line">    while (cin &gt;&gt; a &amp;&amp; cin &gt;&gt; b) &#123; // 持续输入边的起点和终点</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; // 输出当前输入的边</span><br><span class="line">        edge[a][b] = 1; // 在邻接矩阵中标记边（有向边：从a指向b）</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;DFS traversal starting from node 0:&quot; &lt;&lt; endl;</span><br><span class="line">    dfs(0, n); // 从节点0开始进行深度优先搜索</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">6</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">- 图中有6个节点，边为：</span><br><span class="line">    0 -&gt; 1</span><br><span class="line">    0 -&gt; 2</span><br><span class="line">    1 -&gt; 3</span><br><span class="line">    1 -&gt; 4</span><br><span class="line">    2 -&gt; 4</span><br><span class="line">    3 -&gt; 5</span><br><span class="line">- 使用邻接矩阵存储的表示形式：</span><br><span class="line">    0 1 1 0 0 0</span><br><span class="line">    0 0 0 1 1 0</span><br><span class="line">    0 0 0 0 1 0</span><br><span class="line">    0 0 0 0 0 1</span><br><span class="line">    0 0 0 0 0 0</span><br><span class="line">    0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">DFS traversal starting from node 0:</span><br><span class="line">0 1 3 5 4 2</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">0 1 3 5 4 2</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">1. 邻接矩阵通过 `memset` 初始化为0，访问数组初始化为0。</span><br><span class="line">2. 按输入定义的边构建有向图。</span><br><span class="line">3. 从节点0开始深度优先搜索，按DFS规则访问所有可以到达的节点。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 93; // 92个解 + 1，用作数组索引从1开始</span><br><span class="line">int res[N][8];    // 保存所有解</span><br><span class="line">int count_res = 0; // 当前解的数量</span><br><span class="line"></span><br><span class="line">// 深度优先搜索函数</span><br><span class="line">void dfs(int i, int qipan[8][8], int visit[8]) &#123;</span><br><span class="line">    if (i == 8) &#123; // 如果已经放置了8个皇后，记录当前解</span><br><span class="line">        for (int k = 0; k &lt; 8; k++) &#123;</span><br><span class="line">            res[count_res][k] = visit[k];</span><br><span class="line">        &#125;</span><br><span class="line">        count_res++;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j = 0; j &lt; 8; j++) &#123; // 遍历当前行的每一列</span><br><span class="line">        if (qipan[i][j] == 0) &#123;  // 如果当前位置可以放置皇后</span><br><span class="line">            // 保存当前状态</span><br><span class="line">            int temp[8][8];</span><br><span class="line">            memcpy(temp, qipan, sizeof(temp));</span><br><span class="line">            visit[i] = j + 1;   // 记录第i行皇后所在的列（+1表示从1开始计列号）</span><br><span class="line">            </span><br><span class="line">            // 更新棋盘，标记被占用的区域</span><br><span class="line">            for (int k = 0; k &lt; 8; k++) &#123;</span><br><span class="line">                qipan[i][k] = 1; // 当前行</span><br><span class="line">                qipan[k][j] = 1; // 当前列</span><br><span class="line">                if (i + k &lt; 8 &amp;&amp; j + k &lt; 8) qipan[i + k][j + k] = 1; // 主对角线</span><br><span class="line">                if (i + k &lt; 8 &amp;&amp; j - k &gt;= 0) qipan[i + k][j - k] = 1; // 副对角线</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 递归尝试下一行</span><br><span class="line">            dfs(i + 1, qipan, visit);</span><br><span class="line">            </span><br><span class="line">            // 恢复棋盘状态</span><br><span class="line">            memcpy(qipan, temp, sizeof(temp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造所有解</span><br><span class="line">void BHH() &#123;</span><br><span class="line">    int visit[8];     // 记录每行皇后所在的列号</span><br><span class="line">    int qipan[8][8];  // 棋盘，标记被占用的位置</span><br><span class="line">    memset(res, 0, sizeof(res));</span><br><span class="line">    memset(visit, 0, sizeof(visit));</span><br><span class="line">    memset(qipan, 0, sizeof(qipan));</span><br><span class="line">    count_res = 0;</span><br><span class="line">    dfs(0, qipan, visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 预先计算所有八皇后解</span><br><span class="line">    BHH();</span><br><span class="line"></span><br><span class="line">    // 输入处理</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        int b;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">        // 输出第 b 个解</span><br><span class="line">        for (int j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">            cout &lt;&lt; res[b - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day3 algorithm</title>
      <link href="/2024/11/13/day3%20algorithm/"/>
      <url>/2024/11/13/day3%20algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-algorithm"><a href="#第四章-algorithm" class="headerlink" title="第四章 algorithm"></a>第四章 algorithm</h1><p><code>请你为下列代码添加详细的中文注释，并在代码结尾的注释中给出一个测试案例以及对应的标准答案以及代码输出的答案</code></p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;     // 引入标准输入输出流库</span><br><span class="line">#include&lt;algorithm&gt;    // 引入算法库，包含排序函数sort</span><br><span class="line">#include&lt;string&gt;       // 引入字符串库</span><br><span class="line">#include&lt;vector&gt;       // 引入向量（动态数组）库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个结构体stu，用来存储学生的学号和分数</span><br><span class="line">struct stu &#123;</span><br><span class="line">    int num;    // 学号</span><br><span class="line">    int score;  // 分数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 比较两个整数的大小，降序排序</span><br><span class="line">bool cmp1(int a, int b) &#123;</span><br><span class="line">    return a &gt; b;  // 如果a大于b，返回true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 比较两个学生的分数，若分数相同则按照学号升序排列</span><br><span class="line">bool cmp2(stu a, stu b) &#123;</span><br><span class="line">    if(a.score == b.score) &#123;</span><br><span class="line">        return a.num &lt; b.num;  // 如果分数相同，学号小的排在前面</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return a.score &gt; b.score;  // 否则按照分数降序排列</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 定义并初始化一个整数数组</span><br><span class="line">    int a[5] = &#123;5, 4, 2, 1, 3&#125;;</span><br><span class="line">    </span><br><span class="line">    // 使用sort函数对整数数组进行升序排序</span><br><span class="line">    sort(a, a + 5);</span><br><span class="line">    for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;  // 输出排序后的数组</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    // 使用sort函数对整数数组进行降序排序，使用cmp1作为比较函数</span><br><span class="line">    sort(a, a + 5, cmp1);</span><br><span class="line">    for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;  // 输出排序后的数组</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    // 定义一个字符串并进行排序（升序）</span><br><span class="line">    string s = &quot;fasvsADFsdfaSAFGBV&quot;;</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;  // 输出升序排列后的字符串</span><br><span class="line">    </span><br><span class="line">    // 对字符串进行降序排序，使用cmp1作为比较函数</span><br><span class="line">    sort(s.begin(), s.end(), cmp1);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;  // 输出降序排列后的字符串</span><br><span class="line">    </span><br><span class="line">    // 定义并初始化一个整数类型的向量</span><br><span class="line">    vector&lt;int&gt; v = &#123;5, 4, 2, 1, 3&#125;;</span><br><span class="line">    sort(v.begin(), v.end());  // 对向量进行升序排序</span><br><span class="line">    for(auto it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;  // 输出排序后的向量</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    // 对向量进行降序排序，使用cmp1作为比较函数</span><br><span class="line">    sort(v.begin(), v.end(), cmp1);</span><br><span class="line">    for(auto it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;  // 输出排序后的向量</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 定义一个向量来存储学生信息</span><br><span class="line">    vector&lt;stu&gt; stus;</span><br><span class="line">    stu temp;</span><br><span class="line">    </span><br><span class="line">    // 循环读取学生的学号和分数，直到没有更多输入</span><br><span class="line">    while(cin &gt;&gt; temp.num) &#123;</span><br><span class="line">        cin &gt;&gt; temp.score;</span><br><span class="line">        stus.push_back(temp);  // 将输入的学生信息添加到向量中</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 使用sort函数对学生信息进行排序，按照分数降序、学号升序排列</span><br><span class="line">    sort(stus.begin(), stus.end(), cmp2);</span><br><span class="line">    </span><br><span class="line">    // 输出排序后的学生信息</span><br><span class="line">    for(auto it = stus.begin(); it != stus.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;score &lt;&lt; endl;  // 输出学号和分数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">5 90</span><br><span class="line">3 80</span><br><span class="line">1 70</span><br><span class="line">4 95</span><br><span class="line">2 85</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">1 70</span><br><span class="line">3 80</span><br><span class="line">2 85</span><br><span class="line">5 90</span><br><span class="line">4 95</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">1 70</span><br><span class="line">3 80</span><br><span class="line">2 85</span><br><span class="line">5 90</span><br><span class="line">4 95</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;   // 导入输入输出流库，用于处理输入和输出</span><br><span class="line">#include&lt;algorithm&gt;  // 导入算法库，提供常见算法（如查找算法）</span><br><span class="line">#include&lt;vector&gt;     // 导入向量库，支持动态数组的实现</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化一个整型的动态数组（向量），包含一些整数</span><br><span class="line">    vector&lt;int&gt; v = &#123;1, 3, 5, 6, 7&#125;;</span><br><span class="line">    </span><br><span class="line">    // 使用find函数查找向量v中元素5的迭代器，返回第一个找到的元素的地址</span><br><span class="line">    auto it = find(v.begin(), v.end(), 5);</span><br><span class="line">    </span><br><span class="line">    // 检查查找结果：如果找到了元素5</span><br><span class="line">    if (it != v.end()) &#123;</span><br><span class="line">        // 输出找到的元素的值</span><br><span class="line">        cout &lt;&lt; &quot;found: &quot; &lt;&lt; *it &lt;&lt; endl; // 输出找到的元素值</span><br><span class="line">        </span><br><span class="line">        // 计算该元素在向量中的下标</span><br><span class="line">        int index = it - v.begin(); // 迭代器减去起始迭代器得到下标</span><br><span class="line">        cout &lt;&lt; &quot;index: &quot; &lt;&lt; index &lt;&lt; endl; // 输出找到元素的下标</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果找不到元素5，则输出找不到的信息</span><br><span class="line">        cout &lt;&lt; &quot;no found!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试案例：</span><br><span class="line">    // 输入向量为 &#123;1, 3, 5, 6, 7&#125;</span><br><span class="line">    // 查找的元素为 5</span><br><span class="line">    // 预期输出：</span><br><span class="line">    // found: 5</span><br><span class="line">    // index: 2</span><br><span class="line">    </span><br><span class="line">    // 代码的实际输出将是：</span><br><span class="line">    // found: 5</span><br><span class="line">    // index: 2</span><br><span class="line">    // 因为在代码中我们找到了元素5，并输出其值和下标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resever"><a href="#resever" class="headerlink" title="resever"></a>resever</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;   // 导入输入输出流库，用于处理输入和输出</span><br><span class="line">#include&lt;algorithm&gt;  // 导入算法库，提供常见算法（如反转算法）</span><br><span class="line">#include&lt;vector&gt;     // 导入向量库，支持动态数组的实现</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化一个整型的动态数组（向量），包含一些整数</span><br><span class="line">    vector&lt;int&gt; v = &#123;1, 3, 5, 6, 7&#125;;</span><br><span class="line">    </span><br><span class="line">    // 使用reverse函数反转向量v中的元素顺序</span><br><span class="line">    reverse(v.begin(), v.end());</span><br><span class="line">    </span><br><span class="line">    // 使用迭代器遍历反转后的向量，逐个输出元素</span><br><span class="line">    for (auto it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 输出当前迭代器指向的元素</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; // 输出换行以便于后续输出格式整齐</span><br><span class="line">    </span><br><span class="line">    // 使用范围for循环遍历反转后的向量，逐个输出元素</span><br><span class="line">    for (auto i : v) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 输出当前元素</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; // 输出换行以便于整齐</span><br><span class="line"></span><br><span class="line">    // 测试案例：</span><br><span class="line">    // 输入向量为 &#123;1, 3, 5, 6, 7&#125;</span><br><span class="line">    // 经过reverse反转后的向量应为 &#123;7, 6, 5, 3, 1&#125;</span><br><span class="line">    // 预期输出：</span><br><span class="line">    // 7 6 5 3 1 </span><br><span class="line">    // 7 6 5 3 1 </span><br><span class="line"></span><br><span class="line">    // 代码的实际输出将是：</span><br><span class="line">    // 7 6 5 3 1 </span><br><span class="line">    // 7 6 5 3 1 </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day3 容器</title>
      <link href="/2024/11/13/day3%20%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/11/13/day3%20%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-容器"><a href="#第三章-容器" class="headerlink" title="第三章 容器"></a>第三章 容器</h1><p><code>请你为下列代码添加详细的中文注释，并在代码结尾的注释中给出一个测试案例以及对应的标准答案以及代码输出的答案</code></p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;    // 引入标准输入输出流库</span><br><span class="line">#include&lt;vector&gt;      // 引入向量容器库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个空的整型向量v</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    </span><br><span class="line">    // 调整v的大小为10，但不指定初始值，默认会填充为0</span><br><span class="line">    v.resize(10);</span><br><span class="line">    // 输出v的大小，预期为10</span><br><span class="line">    cout &lt;&lt; v.size() &lt;&lt; endl;  // 预期输出10</span><br><span class="line">    </span><br><span class="line">    // 创建一个大小为10的整型向量v1，元素默认初始化为0</span><br><span class="line">    vector&lt;int&gt; v1(10);</span><br><span class="line">    // 输出v1的大小，预期为10</span><br><span class="line">    cout &lt;&lt; v1.size() &lt;&lt; endl;  // 预期输出10</span><br><span class="line">    </span><br><span class="line">    // 创建一个大小为10的整型向量v2，所有元素初始化为1</span><br><span class="line">    vector&lt;int&gt; v2(10, 1);</span><br><span class="line">    // 向v2中添加元素2</span><br><span class="line">    v2.push_back(2);</span><br><span class="line">    // 遍历并输出v2中的所有元素</span><br><span class="line">    for (int i = 0; i &lt; v2.size(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; v2[i] &lt;&lt; &quot; &quot;; // 输出每个元素，元素之间以空格分隔</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; // 换行</span><br><span class="line">    </span><br><span class="line">    // 删除v2中的最后一个元素</span><br><span class="line">    v2.pop_back();</span><br><span class="line">    // 使用迭代器遍历v2并输出元素</span><br><span class="line">    for (auto it = v2.begin(); it != v2.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;  // 输出当前迭代器指向的元素</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; // 换行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">（无输入，代码中已创建并操作向量v、v1、v2）</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 2 </span><br><span class="line">1 1 1 1 1 1 1 1 1 1 </span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 2 </span><br><span class="line">1 1 1 1 1 1 1 1 1 1 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;   // 引入标准输入输出流库</span><br><span class="line">#include&lt;set&gt;        // 引入集合容器库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个整型集合s</span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">    // 向集合s中插入元素</span><br><span class="line">    s.insert(5);  // 插入元素5</span><br><span class="line">    s.insert(5);  // 插入元素5，集合中不会有重复元素，插入无效</span><br><span class="line">    s.insert(1);  // 插入元素1</span><br><span class="line">    s.insert(1);  // 插入元素1，集合中不会有重复元素，插入无效</span><br><span class="line">    s.insert(4);  // 插入元素4</span><br><span class="line">    s.insert(2);  // 插入元素2</span><br><span class="line">    s.insert(3);  // 插入元素3</span><br><span class="line">    s.insert(0);  // 插入元素0</span><br><span class="line"></span><br><span class="line">    // 遍历并输出集合s中的所有元素</span><br><span class="line">    // 注意：set中的元素是有序的，默认按照升序排列</span><br><span class="line">    for (auto it = s.begin(); it != s.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;  // 输出每个元素，元素之间以空格分隔</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;  // 输出换行</span><br><span class="line">    </span><br><span class="line">    // 输出集合s中是否包含元素1，count函数返回元素的个数，set不允许重复元素，所以结果为0或1</span><br><span class="line">    cout &lt;&lt; s.count(1) &lt;&lt; endl;  // 预期输出1，因为元素1存在于集合中</span><br><span class="line">    </span><br><span class="line">    // 从集合s中删除元素1</span><br><span class="line">    s.erase(1);</span><br><span class="line"></span><br><span class="line">    // 再次遍历集合s并输出所有元素</span><br><span class="line">    for (auto it = s.begin(); it != s.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;  // 输出每个元素，元素之间以空格分隔</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;  // 输出换行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">（无输入，代码中已创建并操作集合s）</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">0 1 2 3 4 5 </span><br><span class="line">1</span><br><span class="line">0 2 3 4 5 </span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">0 1 2 3 4 5 </span><br><span class="line">1</span><br><span class="line">0 2 3 4 5 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;   // 引入标准输入输出流库</span><br><span class="line">#include&lt;map&gt;        // 引入映射（字典）容器库</span><br><span class="line">#include&lt;string&gt;     // 引入字符串处理库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个map，键是string类型，值是int类型</span><br><span class="line">    map&lt;string, int&gt; m;</span><br><span class="line"></span><br><span class="line">    // 向map中插入键值对，键是string类型，值是int类型</span><br><span class="line">    m[&quot;hello&quot;] = 2;  // 插入键&quot;hello&quot;，值为2</span><br><span class="line">    m[&quot;world&quot;] = 1;  // 插入键&quot;world&quot;，值为1</span><br><span class="line">    </span><br><span class="line">    // 使用迭代器遍历map，从map的第一个元素开始按升序输出</span><br><span class="line">    // 注意：map中的元素默认是按照键的升序排列的</span><br><span class="line">    for (auto it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;  // 输出键和值</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 使用map的反向迭代器遍历map，从map的最后一个元素开始按降序输出</span><br><span class="line">    // 注意：rbegin()表示从map的最后一个元素开始，rend()表示结束位置</span><br><span class="line">    for (auto it = m.rbegin(); it != m.rend(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;  // 输出键和值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">（无输入，代码中已插入了键值对）</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">hello 2</span><br><span class="line">world 1</span><br><span class="line">world 1</span><br><span class="line">hello 2</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">hello 2</span><br><span class="line">world 1</span><br><span class="line">world 1</span><br><span class="line">hello 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;   // 引入标准输入输出流库</span><br><span class="line">#include&lt;stack&gt;      // 引入栈容器库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个整型栈s</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">    // 向栈中压入元素</span><br><span class="line">    s.push(1);  // 将1压入栈中</span><br><span class="line">    s.push(2);  // 将2压入栈中</span><br><span class="line">    s.push(3);  // 将3压入栈中</span><br><span class="line">    </span><br><span class="line">    // 输出栈顶元素，栈顶元素是3</span><br><span class="line">    cout &lt;&lt; s.top() &lt;&lt; endl;  // 预期输出3</span><br><span class="line">    </span><br><span class="line">    // 输出栈的大小，栈中有3个元素</span><br><span class="line">    cout &lt;&lt; s.size() &lt;&lt; endl;  // 预期输出3</span><br><span class="line">    </span><br><span class="line">    // 弹出栈顶元素</span><br><span class="line">    s.pop();  // 弹出栈顶元素3</span><br><span class="line"></span><br><span class="line">    // 输出新的栈顶元素，栈顶元素现在是2</span><br><span class="line">    cout &lt;&lt; s.top() &lt;&lt; endl;  // 预期输出2</span><br><span class="line">    </span><br><span class="line">    // 输出栈的大小，栈中有2个元素</span><br><span class="line">    cout &lt;&lt; s.size() &lt;&lt; endl;  // 预期输出2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">（无输入，代码中已执行栈的相关操作）</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;   // 引入标准输入输出流库</span><br><span class="line">#include&lt;queue&gt;      // 引入队列容器库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个整型队列q</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">    // 向队列中插入元素</span><br><span class="line">    q.push(1);  // 将1入队</span><br><span class="line">    q.push(2);  // 将2入队</span><br><span class="line">    q.push(3);  // 将3入队</span><br><span class="line">    </span><br><span class="line">    // 输出队列的队头元素和队尾元素</span><br><span class="line">    // 队头元素是1，队尾元素是3</span><br><span class="line">    cout &lt;&lt; q.front() &lt;&lt; &quot; &quot; &lt;&lt; q.back() &lt;&lt; endl;  // 预期输出1 3</span><br><span class="line">    </span><br><span class="line">    // 输出队列的大小，队列中有3个元素</span><br><span class="line">    cout &lt;&lt; q.size() &lt;&lt; endl;  // 预期输出3</span><br><span class="line">    </span><br><span class="line">    // 弹出队列的队头元素</span><br><span class="line">    q.pop();  // 弹出队头元素1</span><br><span class="line"></span><br><span class="line">    // 输出新的队头元素和队尾元素</span><br><span class="line">    // 队头元素现在是2，队尾元素仍然是3</span><br><span class="line">    cout &lt;&lt; q.front() &lt;&lt; &quot; &quot; &lt;&lt; q.back() &lt;&lt; endl;  // 预期输出2 3</span><br><span class="line">    </span><br><span class="line">    // 输出队列的大小，队列中有2个元素</span><br><span class="line">    cout &lt;&lt; q.size() &lt;&lt; endl;  // 预期输出2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">（无输入，代码中已执行队列的相关操作）</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">1 3</span><br><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">1 3</span><br><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="unordered-map-unordered-set"><a href="#unordered-map-unordered-set" class="headerlink" title="unordered_map &amp; unordered_set"></a>unordered_map &amp; unordered_set</h2><p>不自动排序</p><h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;   // 引入标准输入输出流库</span><br><span class="line">#include&lt;bitset&gt;     // 引入位集合（bitset）库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个长度为5的bitset，默认值为00000</span><br><span class="line">    bitset&lt;5&gt; b;</span><br><span class="line">    // 输出bitsetb的二进制表示</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;  // 预期输出: 00000</span><br><span class="line">    </span><br><span class="line">    // 创建三个bitset，分别初始化为1、2、3（默认会转为二进制形式）</span><br><span class="line">    bitset&lt;5&gt; b1(1);  // 1 -&gt; 00001</span><br><span class="line">    bitset&lt;5&gt; b2(2);  // 2 -&gt; 00010</span><br><span class="line">    bitset&lt;5&gt; b3(3);  // 3 -&gt; 00011</span><br><span class="line">    // 输出三个bitset</span><br><span class="line">    cout &lt;&lt; b1 &lt;&lt; &quot; &quot; &lt;&lt; b2 &lt;&lt; &quot; &quot; &lt;&lt; b3 &lt;&lt; endl;  // 预期输出: 00001 00010 00011</span><br><span class="line">    </span><br><span class="line">    // 创建一个bitset，直接通过二进制字符串&quot;100&quot;初始化，剩余位为0</span><br><span class="line">    bitset&lt;5&gt; b4(&quot;100&quot;);  // 二进制字符串初始化：100 -&gt; 00100</span><br><span class="line">    cout &lt;&lt; b4 &lt;&lt; endl;  // 预期输出: 00100</span><br><span class="line">    </span><br><span class="line">    // 使用bitset的成员函数进行一些操作</span><br><span class="line">    cout &lt;&lt; b3.any() &lt;&lt; endl;   // 检查是否有任何位为1，结果为true (1)，预期输出1</span><br><span class="line">    cout &lt;&lt; b3.none() &lt;&lt; endl;  // 检查是否所有位都是0，结果为false (0)，预期输出0</span><br><span class="line">    cout &lt;&lt; b3.count() &lt;&lt; endl; // 计算位为1的个数，结果为2，预期输出2</span><br><span class="line">    cout &lt;&lt; b3.test(0) &lt;&lt; endl; // 测试第0位（从右往左计数），结果为true (1)，预期输出1</span><br><span class="line">    cout &lt;&lt; b3.test(1) &lt;&lt; endl; // 测试第1位，结果为true (1)，预期输出1</span><br><span class="line">    </span><br><span class="line">    // 设置第2位为1</span><br><span class="line">    b3.set(2);</span><br><span class="line">    cout &lt;&lt; b3 &lt;&lt; endl;  // 预期输出: 00111</span><br><span class="line">    </span><br><span class="line">    // 重置第2位为0</span><br><span class="line">    b3.reset(2);</span><br><span class="line">    cout &lt;&lt; b3 &lt;&lt; endl;  // 预期输出: 00011</span><br><span class="line">    </span><br><span class="line">    // 重置所有位为0</span><br><span class="line">    b3.reset();</span><br><span class="line">    cout &lt;&lt; b3 &lt;&lt; endl;  // 预期输出: 00000</span><br><span class="line">    </span><br><span class="line">    // 翻转所有位</span><br><span class="line">    b3.flip();</span><br><span class="line">    cout &lt;&lt; b3 &lt;&lt; endl;  // 预期输出: 11111</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">（无输入，代码中已执行bitset的相关操作）</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">00000</span><br><span class="line">00001 00010 00011</span><br><span class="line">00100</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">00111</span><br><span class="line">00011</span><br><span class="line">00000</span><br><span class="line">11111</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">00000</span><br><span class="line">00001 00010 00011</span><br><span class="line">00100</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">00111</span><br><span class="line">00011</span><br><span class="line">00000</span><br><span class="line">11111</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day2 字符串</title>
      <link href="/2024/11/12/day2%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/11/12/day2%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-字符串"><a href="#第二章-字符串" class="headerlink" title="第二章 字符串"></a>第二章 字符串</h1><p><code>请你为下列代码添加详细的中文注释，并在代码结尾的注释中给出一个测试案例以及对应的标准答案以及代码输出的答案</code></p><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; // 引入标准输入输出流库</span><br><span class="line">#include&lt;string&gt;   // 引入字符串处理库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 定义一个空字符串nullstr并输出，空字符串输出为空行</span><br><span class="line">    string nullstr;</span><br><span class="line">    cout &lt;&lt; nullstr &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    // 创建字符串str，内容为&quot;0123456789&quot;</span><br><span class="line">    string str(&quot;0123456789&quot;);</span><br><span class="line">    // 使用str初始化str1</span><br><span class="line">    string str1(str);</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl; // 输出str1的内容</span><br><span class="line">    </span><br><span class="line">    // 使用str初始化str2，从下标3开始，长度为5的子串</span><br><span class="line">    string str2(str, 3, 5);</span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl; // 输出str2的内容，预期为&quot;34567&quot;</span><br><span class="line">    </span><br><span class="line">    // 使用str初始化str3，从下标3开始到末尾的子串</span><br><span class="line">    string str3(str, 3);</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl; // 输出str3的内容，预期为&quot;3456789&quot;</span><br><span class="line">    </span><br><span class="line">    // 使用前3个字符&quot;012&quot;初始化str4</span><br><span class="line">    string str4(&quot;0123456789&quot;, 3);</span><br><span class="line">    cout &lt;&lt; str4 &lt;&lt; endl; // 输出str4的内容，预期为&quot;012&quot;</span><br><span class="line">    </span><br><span class="line">    // 用5个字符&#x27;0&#x27;初始化str5</span><br><span class="line">    string str5(5, &#x27;0&#x27;);</span><br><span class="line">    cout &lt;&lt; str5 &lt;&lt; endl; // 输出str5的内容，预期为&quot;00000&quot;</span><br><span class="line">    </span><br><span class="line">    // 输出str的大小</span><br><span class="line">    cout &lt;&lt; str.size() &lt;&lt; endl; // 预期为10</span><br><span class="line">    </span><br><span class="line">    // 输出str的长度，size()与length()等价</span><br><span class="line">    cout &lt;&lt; str.length() &lt;&lt; endl; // 预期为10</span><br><span class="line">    </span><br><span class="line">    // 将str和&quot;hello&quot;拼接并输出</span><br><span class="line">    cout &lt;&lt; str + &quot;hello&quot; &lt;&lt; endl; // 预期输出&quot;0123456789hello&quot;</span><br><span class="line">    </span><br><span class="line">    // 在str下标1的位置插入字符串&quot;hello&quot;</span><br><span class="line">    str.insert(1, &quot;hello&quot;);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; // 预期输出&quot;0hello123456789&quot;</span><br><span class="line">    </span><br><span class="line">    // 从下标1位置开始删除5个字符</span><br><span class="line">    str.erase(1, 5);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; // 预期输出&quot;0123456789&quot;</span><br><span class="line">    </span><br><span class="line">    // 从下标0开始替换5个字符为&quot;hello&quot;</span><br><span class="line">    str.replace(0, 5, &quot;hello&quot;);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; // 预期输出&quot;hello56789&quot;</span><br><span class="line">    </span><br><span class="line">    // 从下标5开始替换str末尾的字符，用2个字符&#x27;a&#x27;替换</span><br><span class="line">    str.replace(5, str.length(), 2, &#x27;a&#x27;);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; // 预期输出&quot;helloa&quot;</span><br><span class="line">    </span><br><span class="line">    // 输出str第一个字符的大写形式</span><br><span class="line">    cout &lt;&lt; toupper(str[0]) &lt;&lt; endl; // 预期输出&#x27;H&#x27;</span><br><span class="line">    // 将str第一个字符转换为大写</span><br><span class="line">    str[0] = toupper(str[0]);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; // 预期输出&quot;Helloa&quot;</span><br><span class="line">    </span><br><span class="line">    // 输出str第一个字符的小写形式</span><br><span class="line">    cout &lt;&lt; tolower(str[0]) &lt;&lt; endl; // 预期输出&#x27;h&#x27;</span><br><span class="line">    // 将str第一个字符转换为小写</span><br><span class="line">    str[0] = tolower(str[0]);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; // 预期输出&quot;helloa&quot;</span><br><span class="line">    </span><br><span class="line">    // 查找字符&#x27;l&#x27;在str中的位置</span><br><span class="line">    cout &lt;&lt; str.find(&#x27;l&#x27;) &lt;&lt; endl; // 预期输出2</span><br><span class="line">    // 查找字符&#x27;z&#x27;在str中的位置，若不存在返回string::npos</span><br><span class="line">    cout &lt;&lt; str.find(&#x27;z&#x27;) &lt;&lt; endl; // 预期输出-1或一个大整数（表示未找到）</span><br><span class="line">    </span><br><span class="line">    // 查找子字符串&quot;ll&quot;在str中的位置</span><br><span class="line">    cout &lt;&lt; str.find(&quot;ll&quot;) &lt;&lt; endl; // 预期输出2</span><br><span class="line">    </span><br><span class="line">    // 从下标3开始查找子字符串&quot;ll&quot;的位置</span><br><span class="line">    cout &lt;&lt; str.find(&quot;ll&quot;, 3) &lt;&lt; endl; // 预期输出string::npos</span><br><span class="line">    </span><br><span class="line">    // 从下标3开始向前查找子字符串&quot;ll&quot;的位置</span><br><span class="line">    cout &lt;&lt; str.rfind(&quot;ll&quot;, 3) &lt;&lt; endl; // 预期输出2</span><br><span class="line">    </span><br><span class="line">    // 输入字符串并输出（遇到空格停止）</span><br><span class="line">    string in;</span><br><span class="line">    cin &gt;&gt; in;</span><br><span class="line">    cout &lt;&lt; in &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    // 使用getline读取一整行并输出（包括空格）</span><br><span class="line">    getline(cin, in);</span><br><span class="line">    cout &lt;&lt; in &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">hello world</span><br><span class="line">how are you</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">（以下为程序的多行输出）</span><br><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line">34567</span><br><span class="line">3456789</span><br><span class="line">012</span><br><span class="line">00000</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">0123456789hello</span><br><span class="line">0hello123456789</span><br><span class="line">0123456789</span><br><span class="line">hello56789</span><br><span class="line">helloa</span><br><span class="line">H</span><br><span class="line">Helloa</span><br><span class="line">h</span><br><span class="line">helloa</span><br><span class="line">2</span><br><span class="line">-1</span><br><span class="line">2</span><br><span class="line">npos</span><br><span class="line">2</span><br><span class="line">hello</span><br><span class="line">how are you</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">（以下为代码输出的每一行）</span><br><span class="line">（空行）</span><br><span class="line">0123456789</span><br><span class="line">34567</span><br><span class="line">3456789</span><br><span class="line">012</span><br><span class="line">00000</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">0123456789hello</span><br><span class="line">0hello123456789</span><br><span class="line">0123456789</span><br><span class="line">hello56789</span><br><span class="line">helloa</span><br><span class="line">H</span><br><span class="line">Helloa</span><br><span class="line">h</span><br><span class="line">helloa</span><br><span class="line">2</span><br><span class="line">-1</span><br><span class="line">2</span><br><span class="line">npos</span><br><span class="line">2</span><br><span class="line">hello</span><br><span class="line">how are you</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="splite"><a href="#splite" class="headerlink" title="splite"></a>splite</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;     // 引入标准输入输出流库</span><br><span class="line">#include&lt;string&gt;       // 引入字符串处理库</span><br><span class="line">#include&lt;vector&gt;       // 引入向量容器库</span><br><span class="line">#include&lt;regex&gt;        // 引入正则表达式库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 字符串分割函数</span><br><span class="line">// 参数str为待分割的字符串，sp为分隔符的字符串表示</span><br><span class="line">// 返回值为包含分割后的子字符串的向量</span><br><span class="line">vector&lt;string&gt; stringsplite(string str, string sp) &#123;</span><br><span class="line">    vector&lt;string&gt; res;         // 定义结果向量用于存储分割后的子字符串</span><br><span class="line">    regex re(sp);               // 使用参数sp构建正则表达式对象re</span><br><span class="line">    </span><br><span class="line">    // 使用sregex_token_iterator迭代器，通过正则表达式re分割字符串</span><br><span class="line">    // -1参数表示返回不匹配分隔符的部分（即实际的子字符串）</span><br><span class="line">    copy(sregex_token_iterator(str.begin(), str.end(), re, -1),</span><br><span class="line">         sregex_token_iterator(),</span><br><span class="line">         back_inserter(res));   // 将分割出的子字符串添加到结果向量res中</span><br><span class="line">    </span><br><span class="line">    return res;                 // 返回分割后的子字符串向量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str;                     // 定义一个字符串用于存储输入</span><br><span class="line">    getline(cin, str);              // 读取一行输入并存储到str中</span><br><span class="line">    </span><br><span class="line">    // 调用stringsplite函数，以空格为分隔符分割str</span><br><span class="line">    vector&lt;string&gt; splite_str = stringsplite(str, &quot; &quot;);</span><br><span class="line">    </span><br><span class="line">    // 遍历并输出分割后的每个子字符串</span><br><span class="line">    for (int i = 0; i &lt; splite_str.size(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; splite_str[i] &lt;&lt; endl; // 每个子字符串单独一行输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">hello world this is a test</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">a</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">a</span><br><span class="line">test</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;    // 引入标准输入输出流库</span><br><span class="line">#include &lt;algorithm&gt;   // 引入算法库，包含sort函数</span><br><span class="line">#include &lt;string&gt;      // 引入字符串处理库</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 定义并初始化字符串s，内容为&quot;cdefba&quot;</span><br><span class="line">    string s = &quot;cdefba&quot;;</span><br><span class="line">    </span><br><span class="line">    // 使用sort函数对字符串s的字符进行排序</span><br><span class="line">    // sort(s.begin(), s.end())将字符串s中的字符按照字典序从小到大排序</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    </span><br><span class="line">    // 输出排序后的字符串</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;  // 预期输出&quot;abcdef&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">（无输入，代码中已初始化字符串s为&quot;cdefba&quot;）</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">abcdef</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">abcdef</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day1 排序和查找</title>
      <link href="/2024/11/11/day1%20%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/11/11/day1%20%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-排序和查找"><a href="#第一章-排序和查找" class="headerlink" title="第一章 排序和查找"></a>第一章 排序和查找</h1><p><code>请你为下列代码添加详细的中文注释，并在代码结尾的注释中给出一个测试案例以及对应的标准答案以及代码输出的答案</code></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; // 引入标准输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int size_max = 1e6; // 定义一个常量size_max，值为1000000，用于数组大小</span><br><span class="line">const int N = size_max + 10; // 定义一个常量N，比size_max大10，用于确保数组不会越界</span><br><span class="line"></span><br><span class="line">int n; // 定义全局变量n，用于存储待排序元素的数量</span><br><span class="line">int q[N]; // 定义全局数组q，用于存储待排序的元素</span><br><span class="line"></span><br><span class="line">// 快速排序函数</span><br><span class="line">// 参数q[]为待排序的数组，l为当前处理的子数组左边界，r为当前处理的子数组右边界</span><br><span class="line">void quick_sort(int q[], int l, int r) &#123;</span><br><span class="line">    // 如果当前子数组的左边界大于或等于右边界，说明子数组长度为0或1，无需排序，直接返回</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    </span><br><span class="line">    // 选择子数组左边界元素作为基准值</span><br><span class="line">    int x = q[l];</span><br><span class="line">    // 初始化两个指针，i指向左边界左侧，j指向右边界右侧</span><br><span class="line">    int i = l - 1, j = r + 1;</span><br><span class="line">    </span><br><span class="line">    // 当两个指针没有相遇时，执行以下循环</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 移动指针i，直到找到一个不小于基准值的元素</span><br><span class="line">        while (q[++i] &lt; x);</span><br><span class="line">        // 移动指针j，直到找到一个不大于基准值的元素</span><br><span class="line">        while (q[--j] &gt; x);</span><br><span class="line">        // 如果i和j没有相遇，交换它们指向的元素</span><br><span class="line">        if (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递归地对基准值左侧的子数组进行快速排序</span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    // 递归地对基准值右侧的子数组进行快速排序</span><br><span class="line">    quick_sort(q, j + 1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 从标准输入读取待排序元素的数量</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    // 循环读取每个待排序的元素，并存储到数组q中</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 调用快速排序函数，对数组q进行排序</span><br><span class="line">    quick_sort(q, 0, n - 1);</span><br><span class="line">    </span><br><span class="line">    // 循环输出排序后的数组元素</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, q[i]);</span><br><span class="line">        // 输出元素后加一个空格分隔</span><br><span class="line">        if (i &lt; n - 1) printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出换行符，表示输出结束</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0; // 主函数返回0，表示程序正常结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">3 1 4 1 5</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">1 1 3 4 5</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">1 1 3 4 5</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; // 引入标准输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int size_max = 1e6; // 定义一个常量size_max，值为1000000，用于数组大小</span><br><span class="line">const int N = size_max + 10; // 定义一个常量N，比size_max大10，用于确保数组不会越界</span><br><span class="line"></span><br><span class="line">int n; // 定义全局变量n，用于存储待排序元素的数量</span><br><span class="line">int q[N], tem[N]; // 定义两个全局数组q和tem，q用于存储待排序的元素，tem用于归并排序中的临时数组</span><br><span class="line"></span><br><span class="line">// 归并排序函数，参数q是待排序的数组，l是左边界，r是右边界</span><br><span class="line">void merge_sort(int q[], int l, int r) &#123;</span><br><span class="line">    // 如果左边界大于等于右边界，说明已经不能再分，直接返回</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    </span><br><span class="line">    // 计算中间位置</span><br><span class="line">    int mid = (l + r) &gt;&gt; 1; // 等同于mid = (l + r) / 2，但使用位运算更高效</span><br><span class="line">    </span><br><span class="line">    // 递归地对左半部分进行归并排序</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    // 递归地对右半部分进行归并排序</span><br><span class="line">    merge_sort(q, mid + 1, r);</span><br><span class="line">    </span><br><span class="line">    // 归并两个有序数组</span><br><span class="line">    int i = l, j = mid + 1, k = 0; // 初始化三个指针，i指向左半部分的起始位置，j指向右半部分的起始位置，k指向临时数组的起始位置</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; // 当两个指针都没有到达各自数组的末尾时</span><br><span class="line">        if (q[i] &lt;= q[j]) &#123; // 如果左半部分的当前元素小于等于右半部分的当前元素</span><br><span class="line">            tem[k++] = q[i++]; // 将左半部分的当前元素放入临时数组，并将i和k指针后移</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tem[k++] = q[j++]; // 将右半部分的当前元素放入临时数组，并将j和k指针后移</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将剩余的左半部分元素放入临时数组</span><br><span class="line">    while (i &lt;= mid) tem[k++] = q[i++];</span><br><span class="line">    // 将剩余的右半部分元素放入临时数组</span><br><span class="line">    while (j &lt;= r) tem[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    // 将临时数组中的元素拷贝回原数组</span><br><span class="line">    for (int i = 0, j = l; i &lt; k; i++, j++) &#123;</span><br><span class="line">        q[j] = tem[i]; // 从临时数组拷贝元素到原数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 从标准输入读取元素数量</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    // 从标准输入读取每个元素</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 调用归并排序函数对数组进行排序</span><br><span class="line">    merge_sort(q, 0, n - 1);</span><br><span class="line">    </span><br><span class="line">    // 输出排序后的数组</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, q[i]); // 输出每个元素，后面跟一个空格</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出换行符表示输出结束</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0; // 主函数返回0，表示程序正常结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">6</span><br><span class="line">9 5 2 7 1 8</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">1 2 5 7 8 9 </span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">1 2 5 7 8 9</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; // 引入标准输入输出流库</span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int size_max = 100; // 定义常量size_max，表示数组的最大元素数量</span><br><span class="line">const int N = size_max + 10; // 定义常量N，比size_max大10，用于确保数组不越界</span><br><span class="line"></span><br><span class="line">int n; // 定义全局变量n，用于存储数组a的元素数量</span><br><span class="line">int a[N]; // 定义全局数组a，用于存储第一个整数数组</span><br><span class="line">int m; // 定义全局变量m，用于存储数组b的元素数量</span><br><span class="line">int b[N]; // 定义全局数组b，用于存储第二个整数数组（查询数组）</span><br><span class="line"></span><br><span class="line">// 快速排序函数</span><br><span class="line">// 参数q[]为待排序的数组，l为当前处理的子数组左边界，r为当前处理的子数组右边界</span><br><span class="line">void quick_sort(int q[], int l, int r) &#123;</span><br><span class="line">    // 如果左边界大于或等于右边界，说明子数组长度为0或1，直接返回</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    int x = q[l], i = l - 1, j = r + 1; // x为基准值，i初始化为l-1，j初始化为r+1</span><br><span class="line">    // 循环进行分区操作</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 移动i，直到找到大于等于基准值的元素</span><br><span class="line">        while (q[++i] &lt; x);</span><br><span class="line">        // 移动j，直到找到小于等于基准值的元素</span><br><span class="line">        while (q[--j] &gt; x);</span><br><span class="line">        // 如果i小于j，交换两个元素</span><br><span class="line">        if (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归对基准值左侧的子数组排序</span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    // 递归对基准值右侧的子数组排序</span><br><span class="line">    quick_sort(q, j + 1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分查找函数，检查数组a中是否存在目标值x</span><br><span class="line">// 参数x为查找目标，a[]为数组，l为当前子数组左边界，r为右边界</span><br><span class="line">bool find_x(int x, int a[], int l, int r) &#123;</span><br><span class="line">    // 如果左边界大于右边界，说明区间无效，返回false</span><br><span class="line">    if (l &gt; r) return false;</span><br><span class="line">    int mid = (l + r) &gt;&gt; 1; // 计算中间位置，等同于(l + r) / 2</span><br><span class="line">    // 如果x大于中间元素，缩小搜索区间至右半部分</span><br><span class="line">    if (x &gt; a[mid]) &#123;</span><br><span class="line">        l = mid + 1;</span><br><span class="line">        return find_x(x, a, l, r); // 递归查找右半部分</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果x小于中间元素，缩小搜索区间至左半部分</span><br><span class="line">    else if (x &lt; a[mid]) &#123;</span><br><span class="line">        r = mid - 1;</span><br><span class="line">        return find_x(x, a, l, r); // 递归查找左半部分</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到目标元素，返回true</span><br><span class="line">    else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 读取数组a的元素数量</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    // 读取数组a的元素</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 读取数组b的元素数量</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">    // 读取数组b的元素</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 对数组a进行快速排序，便于后续二分查找</span><br><span class="line">    quick_sort(a, 0, n - 1);</span><br><span class="line">    </span><br><span class="line">    // 对于数组b中的每个元素，判断它是否存在于已排序的数组a中</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        // 如果找到元素，输出&quot;YES&quot;</span><br><span class="line">        if (find_x(b[i], a, 0, n - 1)) &#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则输出&quot;NO&quot;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">测试案例：</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">3 1 4 1 5</span><br><span class="line">3</span><br><span class="line">2 4 5</span><br><span class="line"></span><br><span class="line">标准答案：</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客建立教程</title>
      <link href="/2024/10/17/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E6%95%99%E7%A8%8B/"/>
      <url>/2024/10/17/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>hexo c<br>hexo g<br>hexo d</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
